"../meta_joy/meta.joy" include.
DEFINE 

state-value == 0 at;
next-state == 1 at;
is-final-state == 2 at;

# moves the first element from one list into a list pair with the second: [x rest] ls -> [rest] [ls x]
move-first == swap 
	[null] [swap [] cons] 
	[[rest] [first] cleave swapd [] cons cons] 
	ifte;

# runs a state against an input list: input stack state -> final-state-value
(*
run-state-from-stack == [is-final-state] [state-value] [
	[[input stack state]
		stack state
		[input null] [next-state-no-input] [next-state-with-input] ifte
		infra
		[rest] [first] cleave
	] let-splice;
] tailrec;
*)
 
run-state-from-stack == [is-final-state] [popd popd state-value] [
	[move-first] dip
	next-state i # input [stack value] -> input new-stack new-state
] tailrec;
# dup [state-value] dip rollupd

(* *)
# runs a state from an input list and an empty stack: input state -> final state value
run-state == [] swap run-state-from-stack;

# manipulation of [stack value] pairs
has-input == size 2 =;
no-input == size 1 =; 
cur-stack == 0 at;
input == 1 at;
input-or-default == [has-input] [input] [[]] ifte;
empty-stack == cur-stack null;
non-empty-stack == empty-stack not;

# same as cond, but without the default value
condn == [[]] concat cond;

stack-value-to-map == [[stack-value]
	[[has-input stack-value has-input]
	 [no-input stack-value no-input]
	 [input stack-value input-or-default]
	 [empty-stack stack-value empty-stack]
	 [non-empty-stack stack-value non-empty-stack]]
] let-splice;

state-func == 
	[[cur-stack] [stack-value-to-map] cleave] dip 
	splice-from-map-no-eval infra
	[rest] [first] cleave;

fail == ["fail" [] true];
success == ["success" [] true];
n-zero-ones == ["n-zero-ones" [n-zero-ones-next] false];

n-zero-ones-next == [[
	[[empty-stack no-input and] success]
	[[non-empty-stack no-input and] fail]
	[[input '0 =] input n-zero-ones]
	[[non-empty-stack input '1 = and] pop n-zero-ones]
	[[empty-stack input '1 = and] fail]
] condn] state-func;

(*
n-zero-ones-next == [
	[[[empty-stack] [no-input] cleave and] cur-stack success]
	[[[non-empty-stack] [no-input] cleave and] cur-stack fail]
	[[input '0 =] [input] [cur-stack] cleave cons n-zero-ones]
	[[[non-empty-stack] [input '1 =] cleave and] cur-stack rest n-zero-ones]
	[[[empty-stack] [input '1 =] cleave and] cur-stack fail]
] condn;
*)
.
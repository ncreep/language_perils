"../meta_joy/meta.joy" include.
DEFINE 

(* 
A state is a 2/3 items list, where the first item is the value, 
the second is a transition function and the third is an optional flag to designate
whether a state is final.
The state transition function takes a pair of stack and current value, and produces a new stack and state.
*)

state-value == 0 at;
next-state == 1 at;
is-final-state == 2 at;
has-final-state == size 3 =;

# moves the first element from one list into a list pair with the second argument: [x rest] y -> [rest] [y x]
move-first == swap 
	[null] [swap [] cons] 
	[[rest] [first] cleave swapd [] cons cons] 
	ifte;

(* 
Checks whether the state run is done, this is true if 
 - the state has the final-state attribute and this is a final state
 - the state does not have the final-state attribute, but the input is done
input stack state -> boolean
*)
finish-state-run == 
	[has-final-state] 
	[is-final-state popd popd] # this is a final state
	[pop pop null] # no more input
ifte;

# runs a state against an input list: input stack state -> final-state-value
run-state-from-stack == [finish-state-run] [popd popd state-value] [
	[move-first] dip
	next-state i # input [stack value] -> input new-stack new-state
] tailrec;

(* *)
# runs a state from an input list and an empty stack: input state -> final state value
run-state == [] swap run-state-from-stack;

# manipulation of [stack value] pairs
has-input == size 2 =;
no-input == size 1 =; 
cur-stack == 0 at;
input == 1 at;
input-or-default == [has-input] [input] [[]] ifte;
empty-stack == cur-stack null;
non-empty-stack == empty-stack not;

# applies a function to the top of the stack and returns a new stack: [stack value] func -> new-stack
on-stack  == swap cur-stack uncons [swap i] dip cons;

# same as cond, but without the default value
condn == [[]] concat cond;

# converts a [stack value] pair into a map of relevant data
stack-value-to-map == [[stack-value]
	[[has-input stack-value has-input]
	 [no-input stack-value no-input]
	 [input stack-value input-or-default]
	 [empty-stack stack-value empty-stack]
	 [non-empty-stack stack-value non-empty-stack]]
] let-splice;

(*
Lifts a state transition function into an environment where the output of stack-value-to-map
is available as values. The resulting function is run against the 
stack from the current [stack value] pair. The state transition function should leave
the newly calculated stack and the new state on top of it as a result.
The resulting stack and state are converted into a list and a state on top of it, to be used
for further calculations in run-state-from-stack.
[stack value] state-func -> stack state
*)
state-func == 
	[[cur-stack] [stack-value-to-map] cleave] dip 
	splice-from-map-no-eval infra
	[rest] [first] cleave;
  
# runs the state of a baby, initializing the mistakes count to 0: input state -> final state value
run-baby-state == [0] swap run-state-from-stack;

# increments/decrement the value on the top of the stack
one-up == [succ] on-stack;
one-down == [pred] on-stack;

# the maximal number of failures a parent is allowed to have
max-fail == 3;
  
call-social-worker == ["call-social-worker" [[
  [[input "sing-lullaby" =] cur-stack call-social-worker]
  [[input "feed" =] cur-stack call-social-worker]
  [[input "soothe" =] cur-stack call-social-worker]
] condn]];

  
sleepy == ["sleepy" [[
  [[input "sing-lullaby" =] one-down asleep]
  [[input "feed" =] one-up crying]
  [[input "soothe" =] one-up crying]
] condn]];
  
hungry == ["hungry" [[
  [[input "sing-lullaby" =] one-up crying]
  [[input "feed" =] one-down asleep]
  [[input "soothe" =] one-up crying]
] condn]];
  
asleep == ["asleep" [[
  [[input "sing-lullaby" =] one-up crying]
  [[input "feed" =] one-up crying]
  [[input "soothe" =] one-up crying]
] condn]];
  
crying == ["crying" [[
  [[input "sing-lullaby" =] [cur-stack first max-fail >=] [cur-stack call-social-worker] [one-up crying] ifte]
  [[input "feed" =] [cur-stack first max-fail >=] [cur-stack call-social-worker] [one-up crying] ifte]
  [[input "soothe" =] one-down asleep]
] condn]];


fail == ["fail" [] true];
success == ["success" [] true];
n-zero-ones == ["n-zero-ones" [n-zero-ones-next] false];

n-zero-ones-next == [[
	[[empty-stack no-input and] success]
	[[non-empty-stack no-input and] fail]
	[[input '0 =] input n-zero-ones]
	[[non-empty-stack input '1 = and] pop n-zero-ones]
	[[empty-stack input '1 = and] fail]
] condn] state-func;

(*
n-zero-ones-next == [
	[[[empty-stack] [no-input] cleave and] cur-stack success]
	[[[non-empty-stack] [no-input] cleave and] cur-stack fail]
	[[input '0 =] [input] [cur-stack] cleave cons n-zero-ones]
	[[[non-empty-stack] [input '1 =] cleave and] cur-stack rest n-zero-ones]
	[[[empty-stack] [input '1 =] cleave and] cur-stack fail]
] condn;
*)


# mapping numbers to their corresponding states: num -> state
num-to-state == [ [0 zero] [1 one] [2 two] [3 three] [4 four] [5 five] [[none]]] case;
num-states == 6;

(* Operating on instruction pairs of the form [num cw/acw]. 
[num cw] becomes num, [num acw] becomes -num. *)
inst-sign == [1 at "acw" intern =] [[neg]] [[]] ifte popd;
inst-num == first;
inst-to-num == [inst-num] [inst-sign] cleave i;

# converts a state number and a rotation instruction into the next state: instruction num -> state
# this takes care for the circularity of the states by using modular arithmetic
next-num-state == swap 
	inst-to-num +
	num-states rem # the number modulo the number of states
	num-states + num-states rem # shifting negative numbers
	trunc # making sure we have an integer
	num-to-state;
	
# takes a number and creates a locked state for that number: number -> state
locked-state == [[num] [[num "locked"] [[input num next-num-state] state-func]]] let-splice;

(*
*)
zero == 0 locked-state;
one == 1 locked-state;
three == 3 locked-state;
four == 4 locked-state;
five == 5 locked-state;

two == ["2locked" [[input [
	[[[3 acw] equal] five-on-path]
	[2 next-num-state]
] cond] state-func]];

five-on-path == ["5locked" [[input [
	[[[4 cw] equal] three-on-path]
	[5 next-num-state]
] cond] state-func]];

three-on-path == ["3locked" [[input [
	[[[2 acw] equal] open]
	[3 next-num-state]
] cond] state-func]];

open == ["open" [open] state-func];
.